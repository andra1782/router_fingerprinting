import argparse
import datetime
import json
import logging
import re
import sqlite3
from dataclasses import dataclass

import pandas as pd
from cvss import CVSS2, CVSS3, CVSS4

"""
============================= GLOBALS ============================
"""

logger = logging.getLogger(__name__)
logging.basicConfig(filename='get_cves.log', encoding='utf-8', format='%(asctime)s::%(levelname)s::%(message)s', level=logging.INFO)


con = sqlite3.connect('cve.db') # db connection


vendor_map = None # vendor names found using snmp differ from those in the db, so we define a mapping between them


@dataclass
class Env(argparse.Namespace):
    input: str = 'input.csv'
    # Initially, some vendor names from the snmp scans won't be in the `vendor_mapping.json`. First do a dry run,
    # which will report any missing mappings without doing any db operations. After you're sure all necessary mappings
    # were added, re-run the script for real
    dry_run: bool = False
    severity: float = None
    routers_only: bool = False
    verbose_severity: bool = False


# get CLI args
parser = argparse.ArgumentParser()
parser.add_argument('-i', '--input', type=str, default='input.csv', help='path to the input csv file')
parser.add_argument('-n', '--dry-run', action='store_true', help='only log unknown vendors')
parser.add_argument('-s', '--severity', type=float, default=None,
                    help='include severity metrics with severity larger than the provided value in the output')
parser.add_argument('-r', '--routers-only', action='store_true', help='only report CVEs related to routers')
parser.add_argument('-vs', '--verbose-severity', action='store_true',
                    help='increase verbosity of severity metrics by extracting the information encoded in the cvss vector string')
env = Env(**vars(parser.parse_args()))

"""
============================== METHODS =============================
"""

def vendor_resolution(enterprise: str) -> str:
    """
    Resolve the vendor shortname given the enterprise name obtained from the scanning. The map is stored in 
    `vendor_mapping.json`. 
    :param enterprise: the `enterprise` field from the scanning results
    :return: the shortname of the vendor, as found in the db
    :raises KeyError: if the enterprise is not found in the mapping. Should be manually added to the mapping file
    """
    global vendor_map
    if vendor_map is None: # load it once
        with open('vendor_mapping.json', 'r') as f:
            vendor_map = json.load(f)
    
    if enterprise in vendor_map:
        return vendor_map[enterprise]
    
    # logged
    raise KeyError(f"Enterprise {enterprise} not found in vendor map. Add it to vendor_mapping.json.")


def convert_to_date(time: str) -> datetime.date:
    """
    Calculates the date the last boot took place from the snmpEngineTime field.
    :param time: the value of the snmpEngineTime field
    :return: the `datetime.date` representing the date of the last boot
    """
    days_since_reboot = re.search(r'(\d+)d', str(time)).group(1)
    
    reboot_date = datetime.date.today() - datetime.timedelta(days=int(days_since_reboot))    
    
    return reboot_date


def parse_cvss_vector(vector_string: str) -> dict[str, str]:
    """
    CVSS vector strings encode a lot of information about the severity of a vulnerability. This method takes a 
    cvss vector string and parses it into a dictionary. This is only used when the `--verbose-severity` flag is
    set, since it produces a lot of output. 
    
    You can check https://www.first.org/cvss/specification-document for 
    information on how the 4.0 version is structured.
    :param vector_string: The cvss vector string of the CVE
    :return: A dictionary where the keys are the names of the metrics and the values are the values of the metrics.
    """
    cvss_version = vector_string[5:8]

    return {
        '2.0': CVSS2,
        '3.0': CVSS3,
        '3.1': CVSS3,
        '4.0': CVSS4,
    }[cvss_version](vector_string).as_json()


def find_cves(df_row: pd.Series, ip_cve_mapping: dict[str, list[dict[str, object]]]) -> None:
    """
    Queries the database for any CVEs for the vendor that were published after the date of the last boot.
    :param df_row: a row like in the input csv
    :param ip_cve_mapping: mutable dictionary that is updated with the found CVEs for the ip
    :return: nothing, it updates the dictionary instead
    """
    if df_row['enterprise'] == 'unknown':
        logger.info(f"Enterprise unknown for {df_row['ip']}")
        return
    
    try:
        vendor_shortname = vendor_resolution(df_row['enterprise'])
        reboot_date = convert_to_date(df_row['snmpEngineTime'])

        if env.dry_run:
            return

        selection = 'cveId'
        if env.severity is not None and env.verbose_severity:
            selection += ', vectorString'
        elif env.severity is not None:
            selection += ', baseScore, baseSeverity'

        # selection = 'cveId' + (', baseScore, baseSeverity, vectorString' if env.severity is not None else '')
        
        cve_list = pd.read_sql_query(f"""
            SELECT {selection} FROM cve_metadata WHERE 
            assignerShortName == '{vendor_shortname}' 
            AND datePublished >= '{reboot_date}'
            {'AND relatedToRouters < 2' if env.routers_only else ''}
            {'AND baseScore >= ' + str(env.severity) if env.severity is not None else ''}
        """, con).to_dict('records')

        if env.verbose_severity:
            for i, cve in enumerate(cve_list):
                cve_list[i] |= parse_cvss_vector(cve['vectorString'])

        ip_cve_mapping[df_row['ip']] = cve_list
    except KeyError as e: 
        logger.warning(e)
    

if __name__ == '__main__':
    df = pd.read_csv(env.input)
    df.reset_index()
    
    ip_cve_mapping = {}
    
    for index, row in df.iterrows():
        find_cves(row, ip_cve_mapping)
    
    # dump results to a JSON file
    with open('found_cves.json', 'w') as f:
        json.dump(ip_cve_mapping, f, indent=2)