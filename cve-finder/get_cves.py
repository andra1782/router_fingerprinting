import datetime
import json
import sqlite3

import pandas as pd
import re
import logging

logger = logging.getLogger(__name__)
logging.basicConfig(filename='get_cves.log', encoding='utf-8', format='%(asctime)s::%(levelname)s::%(message)s', level=logging.INFO)

con = sqlite3.connect('cve.db') # db connection

vendor_map = None # vendor names found using snmp differ from those in the db, so we define a mapping between them

# Initially, some vendor names from the snmp scans won't be in the `vendor_mapping.json`. First do a dry run,
# which will report any missing mappings without doing any db operations. After you're sure all necessary mappings
# were added, re-run the script for real
DRY_RUN = True 

def vendor_resolution(enterprise: str) -> str:
    """
    Resolve the vendor shortname given the enterprise name obtained from the scanning. The map is stored in 
    `vendor_mapping.json`. 
    :param enterprise: the `enterprise` field from the scanning results
    :return: the shortname of the vendor, as found in the db
    :raises KeyError: if the enterprise is not found in the mapping. Should be manually added to the mapping file
    """
    global vendor_map
    if vendor_map is None: # load it once
        with open('vendor_mapping.json', 'r') as f:
            vendor_map = json.load(f)
    
    if enterprise in vendor_map:
        return vendor_map[enterprise]
    
    # logged
    raise KeyError(f"Enterprise {enterprise} not found in vendor map. Add it to vendor_mapping.json.")


def convert_to_date(time: str) -> datetime.date:
    """
    Calculates the date the last boot took place from the snmpEngineTime field.
    :param time: the value of the snmpEngineTime field
    :return: the `datetime.date` representing the date of the last boot
    """
    days_since_reboot = re.search(r'(\d+)d', str(time)).group(1)
    
    reboot_date = datetime.date.today() - datetime.timedelta(days=int(days_since_reboot))    
    
    return reboot_date

    
def find_cves(df_row: pd.Series, ip_cve_mapping: dict[str, list[str]]) -> None:
    """
    Queries the database for any CVEs for the vendor that were published after the date of the last boot.
    :param df_row: a row like in the input csv
    :param ip_cve_mapping: mutable dictionary that is updated with the found CVEs for the ip
    :return: nothing, it updates the dictionary instead
    """
    if df_row['enterprise'] == 'unknown':
        logger.info(f"Enterprise unknown for {df_row['ip']}")
        return
    
    try:
        vendor_shortname = vendor_resolution(df_row['enterprise'])
        reboot_date = convert_to_date(df_row['snmpEngineTime'])
        
        if DRY_RUN:
            return
        
        cve_list = pd.read_sql_query(f"""
            SELECT cveId FROM cve_metadata WHERE 
            assignerShortName == '{vendor_shortname}' AND
            datePublished >= '{reboot_date}'
        """, con)['cveId'].tolist()

        ip_cve_mapping[df_row['ip']] = cve_list
    except KeyError as e: 
        logger.warning(e)
    

if __name__ == '__main__':
    df = pd.read_csv('input.csv')
    df.reset_index()
    
    ip_cve_mapping = {}
    
    for index, row in df.iterrows():
        find_cves(row, ip_cve_mapping)
    
    # dump results to a json file
    with open('found_cves.json', 'w') as f:
        json.dump(ip_cve_mapping, f, indent=2)