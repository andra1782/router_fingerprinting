import argparse
import datetime
import json
import logging
import math
import re
import sqlite3
from dataclasses import dataclass

import pandas as pd
from math import isnan

vendor_map = None

logger = logging.getLogger(__name__)
logging.basicConfig(filename='../get_cves.log', encoding='utf-8', format='%(asctime)s::%(levelname)s::%(message)s',
                    level=logging.INFO)

input = '../scan_results'
CON = sqlite3.connect('../cve3.db')
CUR = CON.cursor()

@dataclass
class Env(argparse.Namespace):
    reboot_date_precision: int

parser = argparse.ArgumentParser()

parser.add_argument('-p', '--reboot-date-precision', type=int, default=5, help='second precision with which the reboot date should be computed')

env = Env(**vars(parser.parse_args()))



def vendor_resolution(enterprise: str) -> str | None:
    """
    Resolve the vendor shortname given the enterprise name obtained from the scanning. The map is stored in 
    `vendor_mapping.json`. 
    :param enterprise: the `enterprise` field from the scanning results
    :return: the shortname of the vendor, as found in the db
    :raises KeyError: if the enterprise is not found in the mapping. Should be manually added to the mapping file
    """
    global vendor_map
    if vendor_map is None:  # load it once
        with open('../vendor_mapping.json', 'r') as f:
            vendor_map = json.load(f)
            
    if isnan(enterprise):
        return None
    
    enterprise = str(int(enterprise)) # they are parsed as floats for some reason
    
    if enterprise in vendor_map:
        return vendor_map[enterprise]

    # logged
    logger.warning(f"Enterprise {enterprise} not found in vendor map. Add it to vendor_mapping.json.")
    return None


def convert_to_date(time: str) -> datetime.date:
    """
    Calculates the date the last boot took place from the snmpEngineTime field.
    :param time: the value of the snmpEngineTime field
    :return: the `datetime.date` representing the date of the last boot
    """
    # try:
    day, hour, minute, second = re.search(r'(\d+)d(\d+)h(\d+)m(\d+)s', str(time)).groups()
    # except AttributeError: # if reboot is too recent, they won't have a day field. We can assume it is 0

    reboot_date = datetime.datetime.today() - datetime.timedelta(days=int(day), hours=int(hour), minutes=int(minute), seconds=int(second))
    reboot_date = reboot_date.replace(second=(reboot_date.second // env.reboot_date_precision) * env.reboot_date_precision)

    return reboot_date.strftime('%Y-%m-%dT%H:%M:%S') # round to minutes


def load_input() -> pd.DataFrame:
    """
    Reads all the scan results in the folder given as an argument into a single dataframe.
    :return: The dataframe with all the scan results.
    """
    import os
    files = [pd.read_csv(os.path.join(input, file)) for file in os.listdir(input)]

    return pd.concat(files).reset_index()


if __name__ == '__main__':
    df = load_input().dropna().reset_index()
    
    df['snmpRebootDate'] = df['snmpEngineTime'].apply(convert_to_date)
    df['enterprise'] = df['enterprise'].apply(vendor_resolution)
    df['scan_id'] = df.index
    df = df.set_index('scan_id')
    df = df.drop(['index', 'level_0'], axis=1)
    
    datatypes = {
        'scan_id': 'int',
        'ip': 'string',
        'enterprise': 'string',
        'engineIDFormat': 'int',
        'engineIDData': 'string',
        'snmpEngineBoots': 'int',
        'snmpEngineTime': 'str',
        'snmpRebootDate': 'datetime',
        'country': 'string',
        'city': 'string',
        'asn': 'int',
        'asn_name': 'string',
    }
    
    CUR.execute('DELETE FROM scan_results;')
    
    df.to_sql(name='scan_results', con=CON, if_exists='append', index=False, dtype=datatypes)