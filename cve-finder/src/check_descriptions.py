"""
Sometimes the vendors of devices affected by CVEs are not mentioned anywhere besides the description,
with the express reason of annoying people who want to use them for any useful statistic.

This script searches through the description of CVEs for some vendor names. If it finds any, it creates a
new entry in the `cve_vendors` table for it.
"""
import json
import re
import sqlite3
from typing import Any

CON = sqlite3.connect('../cve3.db')
CUR = CON.cursor()

SURROGATES_MAP = {
    'routeros': 'mikrotik'
}

VENDORS = json.load(open('../vendor_mapping.json', 'r')).values()
VENDOR_RE = re.compile(f" ({'|'.join(list(VENDORS) + list(SURROGATES_MAP.keys()))}) ", flags=re.IGNORECASE)


def find_in_description(description: str) -> list[str]:
    matches = [match.lower() for match in set(VENDOR_RE.findall(description))]
    return [SURROGATES_MAP[match] if match in SURROGATES_MAP else match for match in matches]


def get_id_and_vendors(cve_path: str) -> tuple[str, list[str]]:
    with open(cve_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
        cve_id = data['cveMetadata']['cveId']
        try:
            description = data['containers']['cna']['descriptions'][0]['value']
        except KeyError:
            return cve_id, []
        return cve_id, find_in_description(description)
    
    
def run_query(entries: list[tuple[str, str]]):
    query = '''
        WITH input_data(cve_id, vendor_name) AS (
            VALUES(?, ?)
        )
        INSERT INTO cve_vendor (vendorId, cveLightId, fromDescription)
        SELECT v.vendorId,
               cm.cveLightId,
               true
        FROM input_data id
                 JOIN vendors v ON v.vendorId == (select iv.vendorId from vendors iv where iv.shortVendorName == id.vendor_name limit 1)
                 JOIN cve_metadata cm ON cm.cveId = id.cve_id;
    '''
    print(f"Running query: {query} with values {entries}")
    CUR.executemany(query, entries)
    
    
def expand(x: (str, [str])) -> list[tuple[str, str]]:
    return [(x[0], y) for y in x[1]]


def flatten(xss: list[list[Any]]) -> list[Any]:
    return [x for xs in xss for x in xs]

    
if __name__ == '__main__':
    print(list(VENDORS) + list(SURROGATES_MAP.keys()))
    with open('../hitlist.txt', 'r') as f:
        to_add = flatten([expand(get_id_and_vendors(entry.strip())) for entry in f.readlines()])
        run_query(to_add)