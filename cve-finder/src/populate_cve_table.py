"""
Run only once if needed to create the database. You need to have `cvelistV5-main` in the same folder as this script.
Note that you need to manually update the db schema and create the indexes after this script runs.
"""
import json
import sqlite3
from pathlib import Path

import pandas as pd

con = sqlite3.connect('../cve3.db')

def read_json_to_dataframe(file_path: str) -> pd.DataFrame:
    try:
        if not Path(file_path).exists():
            raise FileNotFoundError(f"JSON file not found: {file_path}")
        return pd.read_json(file_path)
    except Exception as e:
        print(f"Error reading JSON file: {e}")
        return pd.DataFrame()
    
    
def save_to_sqlite(json_list: list[dict]):
    vendor_table = []
    vendor_lookup = {}
    for i, v in enumerate(all_vendors):
        vendor_table.append(v)
        vendor_lookup[v] = i
        
    matching_table = []
    for light_cve_id, v in enumerate(json_list):
        if v['vendorName'] is not None:
            for vendor in v['vendorName']:
                matching_table.append((light_cve_id, vendor_lookup[vendor]))
        v.pop('vendorName')
        
    cve_metadata = pd.DataFrame.from_dict(json_list)
    vendor_table = pd.DataFrame(vendor_table)
    matching_table = pd.DataFrame(matching_table, columns=['cveId', 'vendorId'])
    
    print(cve_metadata.to_sql(name='cve_metadata', con=con, if_exists='replace'))
    print(vendor_table.to_sql(name='vendors', con=con, if_exists='replace'))
    print(matching_table.to_sql(name='cve_vendor', con=con, if_exists='replace'))


def contains_router(description: str) -> bool:
    return 'router' in description.lower()


def read_metadata(filename: str) -> dict:
    with open(filename, 'r', encoding='utf-8') as f:
        data = json.load(f)

        try:  # Try to add `relatedToRouters` field; some old CVEs won't have this, so we wrap it in a try except block
            description = data['containers']['cna']['descriptions'][0]['value']
            related_to_routers = 0 if contains_router(description) else 2
        except KeyError:
            related_to_routers = 1
        # related_to_routers is 0 if the description contains a router, 2 if it does not, and 1 if a description could not be found (we're not sure about it)

        try:  # Same with severity metrics
            raw_metrics = data['containers']['cna']['metrics'][0]

            # Sometimes metrics dictionary exists, but it does not have any cvssV fields. In that case, we catch `IndexErrors`
            latest_cvss_version = [x for x in raw_metrics.keys() if x.startswith('cvssV')][0]

            # We only care about these 3 metrics; any other metrics can be extracted from the vector string
            dict_metrics = {key: raw_metrics[latest_cvss_version][key] for key in
                            ['baseScore', 'baseSeverity', 'vectorString']}
        except (KeyError, IndexError):
            dict_metrics = {'baseScore': None, 'baseSeverity': None, 'vectorString': None}
            
        try:
            vendors = set()
            for entry in data['containers']['cna']['affected']:
                all_vendors.add(entry['vendor'])
                vendors.add(entry['vendor'])
            vendor_names = { "vendorName": list(vendors) }
        except (KeyError, IndexError):    
            vendor_names = { "vendorName": None }
        
        return data['cveMetadata'] | {'relatedToRouters': related_to_routers} | dict_metrics | vendor_names


if __name__ == '__main__':
    print('Are you sure you want to populate the database? This will overwrite any existing data.')

    cursor = con.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
    print(cursor.fetchall())
    
    exit(0)
    metadata_list = []
    all_vendors = set()

    with open('../hitlist.txt', 'r') as hitlist:  # paths of all CVE json files
        for line in hitlist:
            entry = read_metadata(line.strip())
            if entry['vendorName'] is not None:
                all_vendors |= set(entry['vendorName'])
            metadata_list.append(entry)
    
    save_to_sqlite(metadata_list)
